<!DOCTYPE html>

<html>

<head>
  <title>Everything As Code</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/reset.css" />
  <link rel="stylesheet" href="/bundles/article.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
</head>

<body>
  <div id="wrapper">
    <h1 id="everything-as-code" tabindex="-1">Everything As Code</h1>
<p><div class="table-of-contents"><ul><li><a href="#everything-as-code">Everything As Code</a><ul><li><a href="#infrastructure-as-code">Infrastructure as code</a></li><li><a href="#documentation-as-code">Documentation as code</a></li><li><a href="#conclusion">Conclusion</a></li></ul></li></ul></div></p>
<p>The code we write never exists in a vacuum. It needs to be deployed, tested, and maintained. Each of these shares concern with the code, and following the principle of separation by concern, they should not be separated from the code. This means that they should be versioned, tested, and deployed alongside the code. We’re already used to tests as code - it’s hard to imagine a useful test suite that ISN’T code, but infrastructure and documentation are often overlooked.</p>
<p><img src="/articles/the-matrix.png" alt="Neo sees the matrix"></p>
<h2 id="infrastructure-as-code" tabindex="-1">Infrastructure as code</h2>
<p>One of the most common implementations of infrastructure as code is Docker, which encodes the environment configuration in a single, highly portable file that can launch code into a container. However, we can go a step further with tools like Terraform or CloudFormation, which allow us to define entire infrastructure stacks, including dockerised containers.</p>
<p>Terraform and CloudFormation both use declarative configuration files:</p>
<pre class="hljs"><code>data <span class="hljs-string">&quot;archive_file&quot;</span> <span class="hljs-string">&quot;zip&quot;</span> {
  type        <span class="hljs-operator">=</span> <span class="hljs-string">&quot;zip&quot;</span>
  source_file <span class="hljs-operator">=</span> <span class="hljs-string">&quot;source.js&quot;</span>
  output_path <span class="hljs-operator">=</span> <span class="hljs-string">&quot;source.zip&quot;</span>
}

resource <span class="hljs-string">&quot;aws_lambda_function&quot;</span> <span class="hljs-string">&quot;lambda&quot;</span> {
  function_name     <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello world&quot;</span>
  filename          <span class="hljs-operator">=</span> data.archive_file.zip.output_path
  source_code_hash  <span class="hljs-operator">=</span> data.archive_file.zip.output_base64sha256
  role              <span class="hljs-operator">=</span> aws_iam_role.iam_for_lambda.arn
  handler           <span class="hljs-operator">=</span> <span class="hljs-string">&quot;source.handler&quot;</span>
  runtime           <span class="hljs-operator">=</span> <span class="hljs-string">&quot;python3.6&quot;</span>
}
</code></pre>
<p>However, CloudFormation also supports semi-imperative code through the AWS CDK:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">nodejsFunction</span> = <span class="hljs-keyword">new</span> lambda_nodejs.<span class="hljs-title function_ invoke__">NodejsFunction</span>(
  context,
  `LambdaFunction`,
  {
    <span class="hljs-attr">functionName</span>: `MyService`,
    <span class="hljs-attr">handler</span>: <span class="hljs-string">&#x27;handler&#x27;</span>,
    <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/lambda.ts&#x27;</span>,
    <span class="hljs-attr">memorySize</span>: <span class="hljs-number">1024</span>,
    <span class="hljs-attr">runtime</span>: aws_lambda.Runtime.NODEJS_18_X,
    <span class="hljs-attr">logRetention</span>: <span class="hljs-number">14</span>, // days
    <span class="hljs-attr">timeout</span>: Duration.<span class="hljs-title function_ invoke__">seconds</span>(<span class="hljs-number">300</span>),
    <span class="hljs-attr">environment</span>: {
      <span class="hljs-attr">NODE_ENV</span>: <span class="hljs-string">&#x27;production&#x27;</span>,
      <span class="hljs-attr">BUCKET</span>: bucket.bucketName,
    },
  },
);
</code></pre>
<p>I refer to this code as “semi-imperative”, beacuse it is still declarative in the sense that you are describing the desired outcome rather than taking the necessary steps to create it, but it is imperative in the sense that you are writing code that is executed to create the infrastructure. This is a powerful combination, because it unlocks the full power of TypeScript to create reusable, composable infrastructure.</p>
<p>The code that generates the infrastructure can share source code with the code that runs on it. The output of deploying the infrastructure can easily be used by the code that runs on it. The infrastructure is automatically versioned together with the code, and new environments can easily be created simply by creating a new branch and adjusting a few variables.</p>
<h2 id="documentation-as-code" tabindex="-1">Documentation as code</h2>
<p>The hardest thing about code documentation is keeping it up to date. Code changes rapidly, especially during development, and the documentation you wrote yesterday can easily be out of date today. This is why auto-generated documentation is so powerful. It doesn’t require any work to keep up to date - any changes you make will automatically be reflected in the documentation. There are limitations to this of course - not all documentation is captured by the parts that are easily auto-generated, but it’s a good start. If you can integrated some manual documentation processes alongside your auto-generated documentation, you can get the best of both worlds.</p>
<p>A good example of this is <a href="https://swagger.io/">Swagger</a>. Swagger is a specification for documenting REST APIs. There are packages like <a href="https://www.npmjs.com/package/swagger-autogen"><code>swagger-autogen</code></a> that can be used to automatically generated documentation for your <a href="https://www.npmjs.com/package/express"><code>express</code></a> API. With some simple tagging, you can keep your documentation organised, and also add manual descriptions explaining the role of your endpoint:</p>
<pre class="hljs"><code>router.<span class="hljs-keyword">get</span>(<span class="hljs-string">&#x27;/users&#x27;</span>, <span class="hljs-keyword">async</span> ({query: {page}}, res) =&gt; {
  <span class="hljs-comment">// #swagger.summary = &#x27;Allows fetching a page of users&#x27;</span>
  <span class="hljs-keyword">const</span> users = <span class="hljs-keyword">await</span> userService.getPage(page);
  res.json(users);
});
</code></pre>
<p>Now your API is automatically documented, and an application is generated that you can deploy using your infrastructure-as-code setup.</p>
<p>This is just one form of static analysis. Another example is <a href="https://typedoc.org/"><code>typedoc</code></a>, that generates a browseable wiki-style application documentating your applications type signatures. You can also customise this using comment tags to add manual descriptions.</p>
<p>The most advanced form of documentation-as-code is rolling your own static analysis tools. Let’s say you have an event tracking service method:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">track</span> = <span class="hljs-title function_ invoke__">async</span> (
    <span class="hljs-attr">name</span>: <span class="hljs-keyword">string</span>, 
    <span class="hljs-attr">params</span>: Record&lt;<span class="hljs-keyword">string</span>, <span class="hljs-keyword">string</span> | number | <span class="hljs-keyword">boolean</span>&gt;,
  ) =&gt; {
  <span class="hljs-comment">// ...</span>
}

<span class="hljs-title function_ invoke__">track</span>(<span class="hljs-string">&#x27;login&#x27;</span>, {<span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;bob&#x27;</span>, <span class="hljs-attr">success</span>: <span class="hljs-literal">true</span>});
</code></pre>
<p>It’s very valuable for project managers and other stakeholders to be able to see what events are being tracked, and what parameters they take. You can write a static analysis tool using a code parsing library like <a href="https://github.com/eslint/espree"><code>espree</code></a> that scans your codebase for calls to <code>track</code>, and documents where they are being called from, and what parameters they are being called with. You can then generate a user-friendly view of this data, and deploy it as part of your documentation. Once this is encoding as a data-structure, you can also use it to see which events are not being used in your pipelines, or create a searchable list of events.</p>
<h2 id="conclusion" tabindex="-1">Conclusion</h2>
<p>By treating infrastructure and documentation as code, we can version them alongside our code, and deploy them together. This means that we can easily create new environments, and we can be confident that our documentation is up to date. We can also use static analysis tools to generate documentation, and use the data-structures they generate to create new tools and views of our codebase.</p>

  </div>
</body>

</html>